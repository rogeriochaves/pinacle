"use client";

import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import React, { useState } from "react";
import type { UseFormReturn } from "react-hook-form";
import { RESOURCE_TIERS } from "../../lib/pod-orchestration/resource-tier-registry";
import type { ServiceId } from "../../lib/pod-orchestration/service-registry";
import { getTemplateUnsafe } from "../../lib/pod-orchestration/template-registry";
import type { GitHubOrg, GitHubRepo, SetupFormValues } from "../../types/setup";
import { Button } from "../ui/button";
import { Label } from "../ui/label";
import { ConfigurationSummary } from "./configuration-summary";
import { EnvironmentVariables } from "./environment-variables";
import { RepositorySelector } from "./repository-selector";
import { ServiceCustomizer } from "./service-customizer";
import { TemplateSelector } from "./template-selector";
import { TierSelectorSetup } from "./tier-selector-setup";

type EnvVar = {
  key: string;
  value: string;
  isSecret: boolean;
  isAutoGenerated?: boolean;
};

type ConfigureFormProps = {
  form: UseFormReturn<SetupFormValues>;
  onSubmit: (data: SetupFormValues) => Promise<void>;
  repositories: GitHubRepo[];
  isLoadingRepositories: boolean;
  organizations: GitHubOrg[];
  installationUrl: string | null;
};

const DEFAULT_SERVICES: ServiceId[] = [
  "claude-code",
  "vibe-kanban",
  "code-server",
];

// Map agent IDs from landing page to service names
const AGENT_TO_SERVICE_MAP: Record<string, ServiceId> = {
  claude: "claude-code",
  openai: "openai-codex",
  cursor: "cursor-cli",
  gemini: "gemini-cli",
};

export const ConfigureForm = ({
  form,
  onSubmit,
  repositories,
  isLoadingRepositories,
  organizations,
  installationUrl,
}: ConfigureFormProps) => {
  const [envVars, setEnvVars] = useState<EnvVar[]>([]);
  const [showSecrets, setShowSecrets] = useState<Record<number, boolean>>({});
  const [isCreating, setIsCreating] = useState(false);
  const [customServices, setCustomServices] =
    useState<ServiceId[]>(DEFAULT_SERVICES);

  const setupType = form.watch("setupType");
  const selectedRepo = form.watch("selectedRepo");
  const selectedOrg = form.watch("selectedOrg");
  const newRepoName = form.watch("newRepoName");
  const bundle = form.watch("bundle");
  const tier = form.watch("tier");
  const agent = form.watch("agent");

  // Get selected template data
  const selectedTemplate = bundle ? getTemplateUnsafe(bundle) : undefined;

  // Get selected tier or use template's default tier
  const selectedTier = tier || selectedTemplate?.tier || "dev.small";
  const tierData = RESOURCE_TIERS[selectedTier];

  const projectName: string =
    setupType === "repository"
      ? selectedRepo || ""
      : `${selectedOrg || ""}/${newRepoName || ""}`;

  // Auto-select first org for "new" mode
  React.useEffect(() => {
    if (setupType === "new" && organizations.length > 0 && !selectedOrg) {
      form.setValue("selectedOrg", organizations[0].login);
    }
  }, [setupType, organizations, selectedOrg, form]);

  // Initialize services with agent from URL before template is selected
  React.useEffect(() => {
    if (agent && AGENT_TO_SERVICE_MAP[agent] && !selectedTemplate) {
      const selectedCodingAssistant = AGENT_TO_SERVICE_MAP[agent];
      setCustomServices((prev) => {
        const withoutCodingAssistant = prev.filter(
          (service) => !Object.values(AGENT_TO_SERVICE_MAP).includes(service)
        );
        return [selectedCodingAssistant, ...withoutCodingAssistant];
      });
    }
  }, [agent, selectedTemplate]);

  // Clear template selection if switching to "repository" mode with non-blank template
  // biome-ignore lint/correctness/useExhaustiveDependencies: Only want to run when setupType changes
  React.useEffect(() => {
    if (setupType === "repository" && bundle) {
      const isBlankTemplate =
        bundle === "nodejs-blank" || bundle === "python-blank";
      if (!isBlankTemplate) {
        form.setValue("bundle", "");
        form.clearErrors("bundle");
        setEnvVars([]); // Clear environment variables too
      }
    }
  }, [setupType]);

  // Initialize environment variables and services when bundle changes
  React.useEffect(() => {
    if (selectedTemplate) {
      // Initialize environment variables
      const newEnvVars = selectedTemplate.requiredEnvVars.map((key) => {
        const defaultValue = selectedTemplate.envVarDefaults?.[key];
        let value = "";
        let isAutoGenerated = false;

        if (defaultValue) {
          // If it's a function, call it to generate the value
          if (typeof defaultValue === "function") {
            value = defaultValue();
            isAutoGenerated = true;
          } else {
            // Otherwise use the string value directly
            value = defaultValue;
            isAutoGenerated = true;
          }
        }

        return {
          key,
          value,
          isSecret:
            key.includes("SECRET") ||
            key.includes("KEY") ||
            key.includes("TOKEN"),
          isAutoGenerated,
        };
      });
      setEnvVars(newEnvVars);

      // Update custom services to match template's services
      let newServices = [...selectedTemplate.services];

      // If there's an agent from URL, replace the template's coding assistant with the selected one
      if (agent && AGENT_TO_SERVICE_MAP[agent]) {
        const selectedCodingAssistant = AGENT_TO_SERVICE_MAP[agent];
        // Remove any coding assistants from template services
        newServices = newServices.filter(
          (service) => !Object.values(AGENT_TO_SERVICE_MAP).includes(service)
        );
        // Add the selected coding assistant at the beginning
        newServices = [selectedCodingAssistant, ...newServices];
      }

      setCustomServices(newServices);

      form.setValue("bundle", selectedTemplate.id);
    }
  }, [selectedTemplate, form, agent]);

  const addEnvVar = () => {
    setEnvVars([...envVars, { key: "", value: "", isSecret: false }]);
  };

  const updateEnvVar = (
    index: number,
    field: keyof EnvVar,
    value: string | boolean,
  ) => {
    const updated = [...envVars];
    updated[index] = { ...updated[index], [field]: value };

    // Clear auto-generated flag when user manually edits the value
    if (field === "value" && updated[index].isAutoGenerated) {
      updated[index].isAutoGenerated = false;
    }

    setEnvVars(updated);
  };

  const removeEnvVar = (index: number) => {
    setEnvVars(envVars.filter((_, i) => i !== index));
  };

  const toggleSecretVisibility = (index: number) => {
    setShowSecrets((prev) => ({
      ...prev,
      [index]: !prev[index],
    }));
  };

  const handleSubmit = async (data: SetupFormValues) => {
    // Validate required environment variables
    if (selectedTemplate) {
      const missingVars = selectedTemplate.requiredEnvVars.filter((key) => {
        const envVar = envVars.find((ev) => ev.key === key);
        return !envVar || envVar.value.trim() === "";
      });

      if (missingVars.length > 0) {
        // Set error on first missing env var to show user what's missing
        form.setError("envVars", {
          type: "manual",
          message: `Please fill in all required environment variables: ${missingVars.join(", ")}`,
        });

        // Focus on the first missing env var field
        setTimeout(() => {
          const firstMissingKey = missingVars[0];
          const element = document.getElementById(`env-var-${firstMissingKey}`);
          element?.focus();
        }, 100);

        return;
      }
    }

    setIsCreating(true);

    try {
      // Prepare environment variables
      const envVarsObject: Record<string, string> = {};
      envVars.forEach((env) => {
        if (env.key && env.value) {
          envVarsObject[env.key] = env.value;
        }
      });

      data.envVars = envVarsObject;
      data.customServices = customServices;

      await onSubmit(data);
    } catch (error) {
      console.error("Failed to create pod:", error);
      setIsCreating(false);
    }
  };

  const onFormSubmit = () => {
    // Clear any previous env var errors before validation
    form.clearErrors("envVars");

    // Manually trigger form validation
    form.handleSubmit(handleSubmit)();
  };

  return (
    <div className="min-h-screen flex">
      {/* Left side - Form */}
      <div className="flex-4 bg-slate-50 flex justify-end overflow-y-auto">
        <div className="w-full max-w-3xl px-8 py-8">
          {/* Back button with title */}
          <div className="flex items-center gap-3 mb-8">
            <Button variant="ghost" asChild className="-ml-2">
              <Link
                href="/"
                className="font-mono text-slate-600 hover:text-slate-900"
              >
                <ArrowLeft className="mr-2 h-4 w-4" />
                Back
              </Link>
            </Button>
            <h1 className="text-2xl font-mono font-bold text-slate-900">
              Configure Your Pod
            </h1>
          </div>

          <div className="space-y-6">
            {/* Repository Selection */}
            <RepositorySelector
              form={form}
              repositories={repositories}
              isLoadingRepositories={isLoadingRepositories}
              organizations={organizations}
              installationUrl={installationUrl}
            />

            {/* Service Customization */}
            <ServiceCustomizer
              defaultServices={DEFAULT_SERVICES}
              selectedServices={customServices}
              onChange={setCustomServices}
            />

            {/* Template Selection */}
            <div>
              <Label className="text-xs font-mono font-medium text-slate-600 mb-3 block">
                SELECT TEMPLATE
              </Label>
              {form.formState.errors.bundle?.message && (
                <p className="text-red-500 text-xs mb-2 font-mono">
                  {form.formState.errors.bundle.message}
                </p>
              )}
              <TemplateSelector
                selectedTemplate={bundle}
                onTemplateChange={(templateId) => {
                  form.setValue("bundle", templateId);
                  form.clearErrors("bundle");
                }}
                compact={true}
                showOnlyBlank={setupType === "repository"}
              />
            </div>

            {/* Resource Tier Selection */}
            <div>
              <Label className="text-xs font-mono font-medium text-slate-600 mb-3 block">
                COMPUTE RESOURCES
              </Label>
              <TierSelectorSetup
                value={selectedTier}
                onChange={(tierId) =>
                  form.setValue(
                    "tier",
                    tierId as
                      | "dev.small"
                      | "dev.medium"
                      | "dev.large"
                      | "dev.xlarge",
                  )
                }
              />
            </div>

            {/* Environment Variables */}
            <div>
              <EnvironmentVariables
                envVars={envVars}
                showSecrets={showSecrets}
                requiredCount={selectedTemplate?.requiredEnvVars.length || 0}
                requiredKeys={selectedTemplate?.requiredEnvVars || []}
                onUpdate={updateEnvVar}
                onRemove={removeEnvVar}
                onAdd={addEnvVar}
                onToggleSecret={toggleSecretVisibility}
              />
              {form.formState.errors.envVars?.message && (
                <p className="text-red-500 text-xs mt-2 font-mono">
                  {String(form.formState.errors.envVars.message)}
                </p>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Right side - Summary */}
      <ConfigurationSummary
        projectName={projectName}
        selectedTemplate={selectedTemplate}
        tierData={tierData}
        onSubmit={onFormSubmit}
        isCreating={isCreating}
        selectedServices={customServices}
      />
    </div>
  );
};
